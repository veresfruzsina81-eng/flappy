<!doctype html>
<html lang="hu">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Pixel Platformer – közel Mario‑feeling (egyfájlos)</title>
<style>
  :root{
    --sky:#8bd3ff; --sky2:#cfeeff; --hill:#7cc56e; --hill2:#5aa84c;
    --ground:#7c4e1d; --groundTop:#5a3513; --brick:#b0492e; --brick2:#912f1b;
    --q:#f7c84d; --q2:#b98524; --coin:#ffd94d; --flag:#34d399; --pipe:#3aa35e; --pipe2:#2b7a44;
    --player:#ffcc4d; --hat:#e59c00; --enemy:#e74c3c; --ink:#0f172a; --hud:#ffffffcc;
  }
  html,body{height:100%;margin:0;background:linear-gradient(#a6e4ff,#dff5ff);color:var(--ink);font:14px/1.4 system-ui,Segoe UI,Inter,Roboto,Arial,sans-serif}
  #wrap{display:grid;place-items:center;height:100%}
  canvas{background:linear-gradient(180deg,var(--sky),var(--sky2));border-radius:14px;box-shadow:0 16px 60px rgba(2,6,23,.25);image-rendering:pixelated;image-rendering: crisp-edges;}
  .hud{position:fixed;top:10px;left:50%;transform:translateX(-50%);display:flex;gap:16px;padding:8px 12px;background:var(--hud);border-radius:12px;font-weight:800;align-items:center}
  .btnbar{position:fixed;bottom:14px;left:50%;transform:translateX(-50%);display:flex;gap:10px}
  button{border:0;border-radius:10px;padding:8px 12px;background:#ffffffcc;backdrop-filter:blur(4px);font-weight:700;cursor:pointer}
  .kbd{font-family:ui-monospace,Consolas,monospace;background:#e2e8f0;border-radius:6px;padding:2px 6px;margin:0 2px;display:inline-block}
</style>
</head>
<body>
<div id="wrap">
  <div class="hud">Élet: <span id="lives">3</span> • Pont: <span id="score">0</span> • Idő: <span id="time">0</span>s</div>
  <canvas id="game" width="960" height="540" aria-label="Pixel platformer"></canvas>
  <div class="btnbar"><button id="reset">Újra</button><button id="pause">Szünet</button></div>
</div>
<script>
// =============================================================
// "Mario‑feeling" platformer – játékosbarát fizika (coyote time,
// jump buffer, változó ugrás), finom kamera, parallax, egyszerű
// ellenfelek, kérdőblokk, érmek, zászló.
// Minden egy fájlban, külső asset nélkül.
// =============================================================
const cvs=document.getElementById('game');
const ctx=cvs.getContext('2d');
// --- SAFETY: ha valamiért 0 a méret, állítsunk be fix értéket, hogy ne legyen üres a vászon
if (!cvs.width || !cvs.height) { cvs.width = 960; cvs.height = 540; }
ctx.imageSmoothingEnabled = false;

/* ====== Világ méret, csempe, skála ====== */
const TILE=16, SCALE=3;              // logikai 16px csempe, 3x rajzolás
const VW=Math.floor(cvs.width/SCALE); // logikai nézet szélesség
const VH=Math.floor(cvs.height/SCALE);
let camX=0, camY=0;

/* ====== HUD ====== */
const L=id=>document.getElementById(id);
const livesEl=L('lives'), scoreEl=L('score'), timeEl=L('time');

/* ====== Fizika (hangolva klasszikus platformerhez) ====== */
const GRAV=2000;          // px/s^2 (logikai px)
const MOVE_ACC=2200;      // gyorsulás
const MAX_RUN=180;        // max vízszintes sebesség (px/s)
const AIR_ACC=1400;       // levegőben gyengébb gyorsulás
const FRICTION=1800;      // fékezés földön
const JUMP_V=-720;        // kezdeti ugrósebesség (kb. 4 csempéig)
const COYOTE=0.12;        // coyote time (mp)
const JUMP_BUF=0.12;      // jump buffer (mp)

/* ====== Időzítés ====== */
let last=performance.now()/1000; let acc=0; const DT=1/60; // fix 60 FPS integrálás
let run=true; let clock=0;

/* ====== Játékos ====== */
const player={ x:0, y:0, w:12, h:14, vx:0, vy:0, onGround:false, facing:1,
  lives:3, score:0, coyote:0, jbuf:0, wantCut:false, spawn:{x:0,y:0} };

/* ====== Csempék & pálya ====== */
// Jelölések: . üres, # talaj, = lebegő blokk, ? kérdőblokk, c érme,
// e ellenség, p játékos, g cél, |/‾/L/J/I cső/variációk (vizuál)
const LEVEL=[
  "........................................................................",
  "........................................................................",
  "..............c.................c..................c.................g....",
  ".............===..............====..............======..............|||..",
  "....................c...............................................|||..",
  "......c....................?..................c.....................|||..",
  "..............===..............====..............======...................",
  "........................................................................",
  ".....########.........................##########.........................",
  "###############.............#######..#############.............#########",
  "###############.....e.......#######..#############.....e.......#########",
  "###############pppppppppppppp#######..#############ppppppppppppp########",
];
// Magyarázat: alacsony plafon nincs, a legmagasabb platform ~3‑3.5 csempe,
// minden ugrás teljesíthető a fenti JUMP_V mellett. A cél (g) a jobb felső
// részen; csövek csak dísz (|||), de szintérzetet ad.

const H=LEVEL.length, W=LEVEL[0].length;
function tileAt(tx,ty){ if(ty<0||ty>=H||tx<0||tx>=W) return '.'; return LEVEL[ty][tx]; }
function isSolid(ch){ return ch==='#' || ch==='=' || ch==='|' || ch==='‾' || ch==='L' || ch==='J' || ch==='I'; }

/* ====== Objektumok a pályából ====== */
const coins=[]; const blocks=[]; const enemies=[]; let goal=null;
function build(){ coins.length=0; blocks.length=0; enemies.length=0; goal=null;
  for(let y=0;y<H;y++) for(let x=0;x<W;x++){
    const c=LEVEL[y][x];
    if(c==='c') coins.push({x:x*TILE+8,y:y*TILE+8,w:8,h:8,t:0});
    if(c==='?') blocks.push({x:x*TILE,y:y*TILE,w:16,h:16,hit:false});
    if(c==='e') enemies.push(makeGoomba(x*TILE+0,y*TILE-2));
    if(c==='g') goal={x:x*TILE+2,y:y*TILE-96,w:8,h:96};
    if(c==='p'){ player.spawn.x=x*TILE; player.spawn.y=(y-1)*TILE-2; }
  }
  respawn(true);
}

function makeGoomba(x,y){ return {x,y,w:14,h:12,vx:30,vy:0,onGround:false,alive:true,dir:1,turnCD:0}; }

/* ====== Beviteli vezérlés ====== */
const keys={left:0,right:0,jump:0};
addEventListener('keydown',e=>{
  if(e.code==='ArrowLeft'||e.code==='KeyA') keys.left=1;
  if(e.code==='ArrowRight'||e.code==='KeyD') keys.right=1;
  if(e.code==='Space'){ if(!keys.jump) player.jbuf=JUMP_BUF; keys.jump=1; e.preventDefault(); }
});
addEventListener('keyup',e=>{
  if(e.code==='ArrowLeft'||e.code==='KeyA') keys.left=0;
  if(e.code==='ArrowRight'||e.code==='KeyD') keys.right=0;
  if(e.code==='Space'){ keys.jump=0; player.wantCut=true; }
});

/* ====== Ütközés csempékkel ====== */
function collideAABB(x,y,w,h, vx,vy){
  // lépésenként vizsgálunk – egyszerű és stabil
  let px=x+vx, py=y; // X
  const minTX=Math.floor(Math.min(x,px)/TILE)-1, maxTX=Math.floor(Math.max(x+w,px+w)/TILE)+1;
  const minTY=Math.floor(y/TILE)-1, maxTY=Math.floor((y+h)/TILE)+1;
  for(let ty=minTY; ty<=maxTY; ty++) for(let tx=minTX; tx<=maxTX; tx++){
    if(!isSolid(tileAt(tx,ty))) continue; const rx=tx*TILE, ry=ty*TILE;
    if(px < rx+TILE && px+w > rx && py < ry+TILE && py+h > ry){
      if(vx>0) px=rx-w; else if(vx<0) px=rx+TILE; vx=0;
    }
  }
  py+=vy; // Y
  for(let ty=minTY; ty<=maxTY; ty++) for(let tx=minTX; tx<=maxTX; tx++){
    if(!isSolid(tileAt(tx,ty))) continue; const rx=tx*TILE, ry=ty*TILE;
    if(px < rx+TILE && px+w > rx && py < ry+TILE && py+h > ry){
      if(vy>0){ py=ry-h; vy=0; player.onGround=true; player.coyote=COYOTE; }
      else if(vy<0){ py=ry+TILE; vy=0; // fejelt -> kérdőblokk
        if(tileAt(tx,ty)==='?'){ const b=blocks.find(bb=>bb.x===rx && bb.y===ry); if(b && !b.hit){ b.hit=true; player.score+=2; }
      }
    }
  }
  return {x:px,y:py,vx,vy};
}

/* ====== Frissítés ====== */
function update(dt){
  clock+=dt; timeEl.textContent=clock.toFixed(0); livesEl.textContent=player.lives; scoreEl.textContent=player.score;

  // — coyote & buffer
  if(player.coyote>0) player.coyote-=dt; if(player.jbuf>0) player.jbuf-=dt;

  // — vízszintes mozgás
  const acc = player.onGround ? MOVE_ACC : AIR_ACC;
  if(keys.left)  player.vx = Math.max(player.vx - acc*dt, -MAX_RUN);
  if(keys.right) player.vx = Math.min(player.vx + acc*dt,  MAX_RUN);
  if(!keys.left && !keys.right){ // fékezés
    const s=Math.sign(player.vx); const m=Math.max(0, Math.abs(player.vx) - FRICTION*dt);
    player.vx = m * s; if(Math.abs(player.vx)<1) player.vx=0;
  }
  if(player.vx!==0) player.facing = Math.sign(player.vx);

  // — ugrás indítás (coyote + buffer)
  if(player.jbuf>0 && (player.onGround || player.coyote>0)){
    player.vy = JUMP_V; player.onGround=false; player.coyote=0; player.jbuf=0; // elhasználjuk
  }
  // — változó ugrás: elengedéskor levágjuk
  if(player.wantCut && player.vy<0){ player.vy *= 0.55; }
  player.wantCut=false;

  // — gravitáció
  player.vy += GRAV*dt; if(player.vy>800) player.vy=800;

  // — integrálás + ütközés
  player.onGround=false; const col = collideAABB(player.x,player.y,player.w,player.h, player.vx*dt, player.vy*dt);
  player.x=col.x; player.y=col.y; player.vx=col.vx; player.vy=col.vy;

  // — pályaszél / leesés
  if(player.y>VH+64) damage(true);
  if(player.x<0) player.x=0; if(player.x>W*TILE-player.w) player.x=W*TILE-player.w;

  // — coinok
  for(let i=coins.length-1;i>=0;i--){ const c=coins[i]; c.t+=dt; if(hit(player,c)) { coins.splice(i,1); player.score+=5; } }

  // — ellenségek
  for(const e of enemies){ if(!e.alive) continue;
    // egyszerű él-detekció + falfordulás
    e.vy += GRAV*dt; if(e.vy>800) e.vy=800;
    // nézzen a lába elé
    const ahead = e.x + (e.dir>0 ? e.w+1 : -1);
    const feetY = e.y + e.h + 1;
    const tx = Math.floor(ahead/TILE), ty=Math.floor(feetY/TILE);
    if(!isSolid(tileAt(tx,ty))) e.dir*=-1;
    e.vx = 40*e.dir;
    // ütközések
    const r=collideAABB(e.x,e.y,e.w,e.h, e.vx*dt, e.vy*dt);
    e.x=r.x; e.y=r.y; e.vx=r.vx; e.vy=r.vy;
    // játékos interakció
    if(hit(player,e)){
      if(player.vy>0 && player.y+player.h<=e.y+6){ e.alive=false; player.vy=JUMP_V*0.55; player.score+=10; }
      else damage();
    }
  }

  // — cél
  if(goal && aabb(player,{x:goal.x-6,y:goal.y,w:goal.w+12,h:goal.h})) finish();

  // — kamera (deadzone + simítás)
  const dz=80; const targetX = clamp(player.x - VW/2 + player.w/2, 0, W*TILE - VW);
  camX += (targetX - camX) * 0.12; camY=0; // nincs vertikális követés most
}

/* ====== Segéd ====== */
const clamp=(v,a,b)=>Math.max(a,Math.min(b,v));
function aabb(a,b){return a.x<b.x+b.w && a.x+a.w>b.x && a.y<b.y+b.h && a.y+a.h>b.y}
function hit(a,b){return aabb({x:a.x,y:a.y,w:a.w,h:a.h},{x:b.x,y:b.y,w:b.w,h:b.h});}

function respawn(init=false){
  player.x=player.spawn.x; player.y=player.spawn.y; player.vx=0; player.vy=0; player.onGround=false; player.coyote=0; player.jbuf=0; player.wantCut=false;
  if(!init) player.lives--; if(player.lives<0){ gameOver(); }
}
function damage(fall=false){ respawn(); }
function finish(){ run=false; alert(`Nyertél! Pont: ${player.score} – Idő: ${timeEl.textContent}s`); }
function gameOver(){ run=false; alert(`Vége! Pont: ${player.score} – Idő: ${timeEl.textContent}s`); }

/* ====== Rajzolás ====== */
function draw(){
  // skála
  ctx.setTransform(SCALE,0,0,SCALE,0,0);
  // teljes törlés biztosan a skálázott térben
  ctx.clearRect(0,0,VW,VH);
  // háttér
  ctx.fillStyle="#a6e4ff"; ctx.fillRect(0,0,VW,VH);
  // parallax dombok és felhők
  drawBackground();
  // csempék
  for(let y=0;y<H;y++){
    for(let x=0;x<W;x++){
      const ch=tileAt(x,y); const px=x*TILE - camX, py=y*TILE - camY; if(px<-TILE||px>VW||py<-TILE||py>VH) continue;
      if(ch==='#' || ch==='='){ drawGround(px,py); }
      if(ch==='|'||ch==='‾'||ch==='L'||ch==='J'||ch==='I'){ drawPipe(px,py); }
      if(ch==='?'){ drawQ(px,py, blocks.find(b=>b.x===x*TILE && b.y===y*TILE)?.hit ); }
      if(ch==='g'){ drawFlag(px+2, py-96); }
    }
  }
  // blokkok (vizuál már fent van)

  // coinok
  for(const c of coins){ const px=c.x - camX, py=c.y - camY; if(px<-16||px>VW+16) continue; drawCoin(px,py,c.t); }
  // ellenségek
  for(const e of enemies){ if(!e.alive) continue; const px=e.x - camX, py=e.y - camY; if(px<-32||px>VW+32) continue; drawGoomba(px,py,e.dir); }
  // játékos
  drawPlayer(player.x - camX, player.y - camY);
}

function drawBackground(){
  // talaj sáv a horizonton
  ctx.fillStyle='#dff5ff'; ctx.fillRect(0,VH-60,VW,60);
  // dombok
  ctx.fillStyle=getVar('--hill'); tri(80-camX*0.3,VH-60,100); tri(300-camX*0.25,VH-60,140); tri(560-camX*0.2,VH-60,120);
  ctx.fillStyle=getVar('--hill2'); tri(180-camX*0.2,VH-60,70); tri(420-camX*0.18,VH-60,90);
  // felhők
  cloud(120-camX*0.1,60); cloud(360-camX*0.12,40); cloud(640-camX*0.08,70);
}
function tri(cx,by,s){ ctx.beginPath(); ctx.moveTo(cx,by); ctx.lineTo(cx-s,by); ctx.lineTo(cx,by-s); ctx.closePath(); ctx.fill(); }
function cloud(x,y){ bubble(x,y,12); bubble(x+12,y-6,10); bubble(x+26,y,12); bubble(x+38,y-4,8); }
function bubble(x,y,r){ ctx.beginPath(); ctx.arc(x,y,r,0,Math.PI*2); ctx.fillStyle='rgba(255,255,255,.95)'; ctx.fill(); }

function drawGround(x,y){ ctx.fillStyle=getVar('--ground'); ctx.fillRect(x,y,TILE,TILE); ctx.fillStyle=getVar('--groundTop'); ctx.fillRect(x,y+TILE-4,TILE,4); }
function drawPipe(x,y){ ctx.fillStyle=getVar('--pipe'); ctx.fillRect(x,y,TILE,TILE); ctx.fillStyle=getVar('--pipe2'); ctx.fillRect(x+2,y+TILE-5,TILE-4,5); }
function drawQ(x,y,hit){ ctx.fillStyle= hit? '#ffe08a' : getVar('--q'); rr(x,y,16,16,3); ctx.fill(); ctx.fillStyle=getVar('--q2'); ctx.fillRect(x+6,y+4,2,2); ctx.fillRect(x+8,y+4,2,2); ctx.fillRect(x+6,y+8,2,2); ctx.fillRect(x+8,y+8,2,2); ctx.fillRect(x+7,y+12,2,2); }
function drawCoin(x,y,t){ ctx.save(); ctx.translate(x,y); ctx.rotate(Math.sin(t*8)*0.2); rr(-6,-6,12,12,6); ctx.fillStyle=getVar('--coin'); ctx.fill(); ctx.restore(); }
function drawFlag(x,y){ ctx.fillStyle='#9ca3af'; ctx.fillRect(x,y,4,96); ctx.fillStyle=getVar('--flag'); ctx.beginPath(); ctx.moveTo(x+4,y+14); ctx.lineTo(x+28,y+8); ctx.lineTo(x+28,y+22); ctx.closePath(); ctx.fill(); }
function drawGoomba(x,y,dir){ ctx.fillStyle=getVar('--enemy'); rr(x,y,14,12,3); ctx.fill(); ctx.fillStyle='#111'; ctx.fillRect(x+3,y+4,2,2); ctx.fillRect(x+9,y+4,2,2); }
function drawPlayer(x,y){
  // kis pixel‑figura anim nélkül (futásnál később bővíthető)
  ctx.fillStyle=getVar('--player'); rr(x,y,12,14,3); ctx.fill();
  ctx.fillStyle=getVar('--hat'); ctx.fillRect(x,y-3,12,3); // sapka
  ctx.fillStyle='#111'; ctx.fillRect(x+8,y+3,2,2); // szem
}
function rr(x,y,w,h,r){ const t=Math.min(r,Math.abs(w)/2,Math.abs(h)/2); ctx.beginPath(); ctx.moveTo(x+t,y); ctx.arcTo(x+w,y,x+w,y+h,t); ctx.arcTo(x+w,y+h,x,y+h,t); ctx.arcTo(x,y+h,x,y,t); ctx.arcTo(x,y,x+w,y,t); ctx.closePath(); }
function getVar(n){ return getComputedStyle(document.documentElement).getPropertyValue(n).trim(); }

/* ====== Ciklus ====== */
function frame(){
  const now=performance.now()/1000; let dt=now-last; last=now; acc+=dt; if(dt>0.25) acc=0; // tab váltás védő
  while(acc>=DT){ update(DT); acc-=DT; }
  draw(); if(run) requestAnimationFrame(frame);
}

/* ====== UI ====== */
document.getElementById('reset').onclick=()=>{ player.lives=3; player.score=0; clock=0; respawn(true); run=true; };
document.getElementById('pause').onclick=()=>{ run=!run; if(run) { last=performance.now()/1000; requestAnimationFrame(frame); } };

/* ====== Start ====== */
function init(){
  console.log('init() start');
  build();
  last = performance.now()/1000;
  run = true;
  // Azonnali első frame, hogy a háttér látszódjon akkor is, ha a loop késik
  frame();
}
// Várjuk meg, hogy a DOM készen álljon (különösen mobilon / lassabb gépen)
document.addEventListener('DOMContentLoaded', init);
</script>
</body>
</html>

