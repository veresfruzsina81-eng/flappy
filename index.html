<!doctype html>
<html lang="hu">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Pixel Plumber – klasszikus Mario‑hangulat (egyfájlos)</title>
<style>
  :root{
    --sky1:#8bd3ff; --sky2:#dff5ff;
    --hill1:#7cc56e; --hill2:#5aa84c;
    --ground:#7c4e1d; --groundTop:#5a3513;
    --brick:#b0492e; --brick2:#912f1b;
    --q:#f7c84d; --q2:#b98524; --qHit:#ffe08a;
    --pipe:#3aa35e; --pipe2:#2b7a44;
    --coin:#ffd94d; --flag:#34d399; --flag2:#16a34a;
    --player:#ffcc4d; --hat:#e59c00; --eye:#111;
    --enemy:#e74c3c; --shell:#3b82f6; --shell2:#1d4ed8;
    --hud:#ffffffcc; --ink:#0f172a;
  }
  html,body{height:100%;margin:0;background:linear-gradient(var(--sky1),var(--sky2));color:var(--ink);font:14px/1.4 system-ui,Segoe UI,Inter,Roboto,Arial,sans-serif}
  #wrap{display:grid;place-items:center;height:100%}
  canvas{background:linear-gradient(180deg,var(--sky1),var(--sky2));border-radius:14px;box-shadow:0 18px 70px rgba(2,6,23,.25);image-rendering:pixelated;image-rendering: crisp-edges;}
  .hud{position:fixed;top:10px;left:50%;transform:translateX(-50%);display:flex;gap:16px;padding:8px 12px;background:var(--hud);border-radius:12px;font-weight:800;align-items:center}
  .btnbar{position:fixed;bottom:14px;left:50%;transform:translateX(-50%);display:flex;gap:10px}
  button{border:0;border-radius:10px;padding:8px 12px;background:#ffffffcc;backdrop-filter:blur(4px);font-weight:700;cursor:pointer}
  .kbd{font-family:ui-monospace,Consolas,monospace;background:#e2e8f0;border-radius:6px;padding:2px 6px;margin:0 2px;display:inline-block}
</style>
</head>
<body>
<div id="wrap">
  <div class="hud">Élet: <span id="lives">3</span> • Pont: <span id="score">0</span> • Idő: <span id="time">0</span>s • Állapot: <span id="state">kicsi</span></div>
  <canvas id="game" width="960" height="540" aria-label="Pixel Plumber"></canvas>
  <div class="btnbar"><button id="reset">Újra</button><button id="pause">Szünet</button></div>
</div>
<script>
// =============================================================
// Pixel Plumber – klasszikus Mario‑hangulat modern, egyfájlos változata
// - Játékosbarát fizika: coyote time, jump buffer, változó ugrás
// - Csempés pálya: talaj, tégla (törhető nagyban), kérdőblokk (érme/powerup)
// - Ellenségek: sétáló "gomba" és páncélos – ráugrás, páncél rúgható
// - Power‑up: gomba -> nagy karakter (téglatörés fejjel alulról)
// - Parallax háttér, zászló cél, kamera dead‑zone
// Nincs külső asset; minden rajzolás kódból.
// =============================================================

/* ====== Canvas & skála ====== */
const cvs=document.getElementById('game');
const ctx=cvs.getContext('2d');
if(!cvs.width||!cvs.height){cvs.width=960;cvs.height=540;}
ctx.imageSmoothingEnabled=false;
const SCALE=3; // 3x pixel-art
const VW=Math.floor(cvs.width/SCALE), VH=Math.floor(cvs.height/SCALE);
let camX=0;

/* ====== HUD refs ====== */
const livesEl=id('lives'), scoreEl=id('score'), timeEl=id('time'), stateEl=id('state');
function id(x){return document.getElementById(x)}

/* ====== Fizika ====== */
const TILE=16;
const GRAV=2000, MOVE_ACC=2200, AIR_ACC=1400, MAX_RUN=180, FRICTION=1800;
const JUMP_V=-720, COYOTE=0.12, JUMP_BUF=0.12;

/* ====== Időzítés ====== */
let last=performance.now()/1000, acc=0; const DT=1/60; let run=true; let clock=0;

/* ====== Játékos ====== */
const player={x:0,y:0,w:12,h:14,vx:0,vy:0,onGround:false,facing:1,
  lives:3,score:0,coyote:0,jbuf:0,wantCut:false,big:false,spawn:{x:0,y:0}};

/* ====== Pálya ====== */
// Legend: . üres, # talaj, B tégla, ? kérdő, | cső, = lebegő blokk, c érme, 
// e gomba, t páncélos, p spawn, G zászló (cél)
const LEVEL=[
  "................................................................................",
  "................................................................................",
  ".................c...............c..................c.....................G......",
  "..............====...........B?B====...........B?B====....................|||...",
  "......................c...................................................|||...",
  ".....c.............B?B.................c..............B?B.................|||...",
  "..............====...........B B====...........B B====..........................",
  "................................................................................",
  ".....##############################........###############......................",
  "###############.............#######..############################......#########",
  "###############....e....t...#######..############################..e...#########",
  "###############ppppppppppppp#######..############################pppppp#########",
];
const H=LEVEL.length, W=LEVEL[0].length;
function tileAt(tx,ty){ if(ty<0||ty>=H||tx<0||tx>=W) return '.'; return LEVEL[ty][tx]; }
function isSolid(ch){ return ch==='#'||ch==='='||ch==='B'||ch==='|' ; }

/* ====== Objektumok ====== */
const coins=[], blocks=[], enemies=[], items=[]; let goal=null;
function build(){ coins.length=0; blocks.length=0; enemies.length=0; items.length=0; goal=null;
  for(let y=0;y<H;y++) for(let x=0;x<W;x++){
    const c=LEVEL[y][x]; const rx=x*TILE, ry=y*TILE;
    if(c==='c') coins.push({x:rx+8,y:ry+8,w:8,h:8,t:0});
    if(c==='?') blocks.push({x:rx,y:ry,w:16,h:16,hit:false,kind: (Math.random()<0.7?'coin':'mush')});
    if(c==='B') blocks.push({x:rx,y:ry,w:16,h:16,hit:false,kind:'brick'});
    if(c==='e') enemies.push(makeGoomba(rx,ry-2));
    if(c==='t') enemies.push(makeTurtle(rx,ry-2));
    if(c==='G') goal={x:rx+2,y:ry-96,w:8,h:96};
    if(c==='p'){ player.spawn.x=rx; player.spawn.y=ry-2; }
  }
  respawn(true);
}

/* ====== Ellenségek / Itemek ====== */
function makeGoomba(x,y){return {type:'goomba',x,y,w:14,h:12,dir:-1,vx:-40,vy:0,alive:true}};
function makeTurtle(x,y){return {type:'turtle',x,y,w:14,h:14,dir:-1,vx:-35,vy:0,alive:true,shell:false,slide:false}};
function spawnMushroom(x,y){items.push({type:'mush',x,y,w:12,h:12,vx:40*(Math.random()<0.5?-1:1),vy:0});}

/* ====== Input ====== */
const keys={left:0,right:0,jump:0};
addEventListener('keydown',e=>{
  if(e.code==='ArrowLeft'||e.code==='KeyA') keys.left=1;
  if(e.code==='ArrowRight'||e.code==='KeyD') keys.right=1;
  if(e.code==='Space'){ if(!keys.jump) player.jbuf=JUMP_BUF; keys.jump=1; e.preventDefault(); }
});
addEventListener('keyup',e=>{
  if(e.code==='ArrowLeft'||e.code==='KeyA') keys.left=0;
  if(e.code==='ArrowRight'||e.code==='KeyD') keys.right=0;
  if(e.code==='Space'){ keys.jump=0; player.wantCut=true; }
});

/* ====== WebAudio minimál SFX ====== */
const AC=window.AudioContext?new AudioContext():null; const master=AC?AC.createGain():null; if(master){master.connect(AC.destination); master.gain.value=0.2}
function beep(f=440,d=0.06,type='square'){ if(!AC) return; const t=AC.currentTime; const o=AC.createOscillator(), g=AC.createGain(); o.type=type; o.frequency.value=f; g.gain.setValueAtTime(0.0001,t); g.gain.exponentialRampToValueAtTime(0.15,t+0.02); g.gain.exponentialRampToValueAtTime(0.0001,t+d); o.connect(g).connect(master); o.start(t); o.stop(t+d+0.02); }
addEventListener('pointerdown',()=>{ if(AC&&AC.state==='suspended') AC.resume(); },{once:true});

/* ====== Kollízió csempékkel ====== */
function collide(x,y,w,h, vx,vy){
  // X irány
  let nx=x+vx, ny=y; const minTX=Math.floor(Math.min(x,nx)/TILE)-1, maxTX=Math.floor(Math.max(x+w,nx+w)/TILE)+1; const minTY=Math.floor(y/TILE)-1, maxTY=Math.floor((y+h)/TILE)+1;
  for(let ty=minTY;ty<=maxTY;ty++)for(let tx=minTX;tx<=maxTX;tx++){
    const ch=tileAt(tx,ty); if(!isSolid(ch)) continue; const rx=tx*TILE, ry=ty*TILE;
    if(nx < rx+TILE && nx+w > rx && ny < ry+TILE && ny+h > ry){ if(vx>0) nx=rx-w; else if(vx<0) nx=rx+TILE; vx=0; }
  }
  // Y irány
  ny+=vy; let onG=false;
  for(let ty=minTY;ty<=maxTY;ty++)for(let tx=minTX;tx<=maxTX;tx++){
    const ch=tileAt(tx,ty); const rx=tx*TILE, ry=ty*TILE; if(!isSolid(ch)) continue;
    if(nx < rx+TILE && nx+w > rx && ny < ry+TILE && ny+h > ry){
      if(vy>0){ ny=ry-h; vy=0; onG=true; player.coyote=COYOTE; }
      else if(vy<0){ ny=ry+TILE; vy=0; // fejelt
        // tégla: csak nagyban törhető
        if(ch==='B' && player.big){ breakBrick(rx,ry); beep(300,0.06,'triangle'); }
        // kérdő: egyszeri loot
        if(ch==='?'){ hitQuestion(rx,ry); }
      }
    }
  }
  return {x:nx,y:ny,vx,vy,onG};
}
function breakBrick(rx,ry){
  // vizuálisan nem animálunk, csak logikailag: a blokkot "üresnek" tekintjük
  const idx=blocks.findIndex(b=>b.x===rx&&b.y===ry&&b.kind==='brick');
  if(idx>=0) blocks.splice(idx,1);
  // A csempe mátrixot nem írjuk át – rajzoláskor a csempét úgyis a blocks listából visszük
}
function hitQuestion(rx,ry){
  const b=blocks.find(bb=>bb.x===rx && bb.y===ry && bb.kind!=='brick'); if(!b||b.hit) return; b.hit=true; player.score+=2; beep(900,0.06,'triangle');
  if(b.kind==='mush') spawnMushroom(rx+2,ry-14);
}

/* ====== Segéd ====== */
const clamp=(v,a,b)=>Math.max(a,Math.min(b,v));
function AABB(a,b){return a.x<b.x+b.w && a.x+a.w>b.x && a.y<b.y+b.h && a.y+a.h>b.y}

/* ====== Játék logika ====== */
function update(dt){
  clock+=dt; timeEl.textContent=clock.toFixed(0); livesEl.textContent=player.lives; scoreEl.textContent=player.score; stateEl.textContent=player.big?'nagy':'kicsi';

  // coyote & buffer
  if(player.coyote>0) player.coyote-=dt; if(player.jbuf>0) player.jbuf-=dt;

  // vízszintes
  const acc = player.onGround?MOVE_ACC:AIR_ACC;
  if(keys.left)  player.vx=Math.max(player.vx-acc*dt, -MAX_RUN);
  if(keys.right) player.vx=Math.min(player.vx+acc*dt,  MAX_RUN);
  if(!keys.left && !keys.right){ const s=Math.sign(player.vx); const m=Math.max(0,Math.abs(player.vx)-FRICTION*dt); player.vx=m*s; if(Math.abs(player.vx)<1) player.vx=0; }
  if(player.vx!==0) player.facing=Math.sign(player.vx);

  // ugrás indítás
  if(player.jbuf>0 && (player.onGround||player.coyote>0)){ player.vy=JUMP_V*(player.big?1.02:1); player.onGround=false; player.coyote=0; player.jbuf=0; beep(700,0.07,'square'); }
  // változó ugrás
  if(player.wantCut && player.vy<0){ player.vy*=0.55; } player.wantCut=false;

  // gravitáció
  player.vy+=GRAV*dt; if(player.vy>800) player.vy=800;

  // integrálás & kollízió
  player.onGround=false; const r=collide(player.x,player.y, player.w, player.h+(player.big?10:0), player.vx*dt, player.vy*dt);
  player.x=r.x; player.y=r.y; player.vx=r.vx; player.vy=r.vy; player.onGround=r.onG;

  // leesés
  if(player.y>VH+64) respawn();

  // coinok
  for(let i=coins.length-1;i>=0;i--){ const c=coins[i]; c.t+=dt; if(AABB(player,c)){ coins.splice(i,1); player.score+=5; beep(1000,0.05,'triangle'); }}

  // itemek (gomba)
  for(let i=items.length-1;i>=0;i--){ const it=items[i]; it.vy+=GRAV*dt; if(it.vy>800) it.vy=800; let rr=collide(it.x,it.y,it.w,it.h, it.vx*dt, it.vy*dt); it.x=rr.x; it.y=rr.y; it.vx=rr.vx; it.vy=rr.vy; if(AABB(player,it)){ items.splice(i,1); powerUp(); }}

  // ellenségek
  for(const e of enemies){ if(!e.alive) continue; e.vy+=GRAV*dt; if(e.vy>800) e.vy=800; // él‑detektálás
    const ahead=e.x+(e.dir>0?e.w+1:-1), feet=e.y+e.h+1; const tx=Math.floor(ahead/TILE), ty=Math.floor(feet/TILE);
    if(!isSolid(tileAt(tx,ty))) e.dir*=-1; e.vx=(e.shell&&e.slide)?(e.dir*140):(e.dir*(e.type==='goomba'?40:35));
    // integrálás
    const rr=collide(e.x,e.y,e.w,e.h, e.vx*dt, e.vy*dt); e.x=rr.x; e.y=rr.y; e.vx=rr.vx; e.vy=rr.vy; e.onGround=rr.onG;
    // játékos interakció
    if(AABB(player,e)){
      if(player.vy>0 && player.y+player.h <= e.y+6){ // felülről
        if(e.type==='goomba'){ e.alive=false; player.vy=JUMP_V*0.55; player.score+=10; beep(500,0.05,'square'); }
        else if(e.type==='turtle'){
          if(!e.shell){ e.shell=true; e.vx=0; e.dir= (player.x<e.x?1:-1); player.vy=JUMP_V*0.55; beep(450,0.05,'square'); }
          else { // shell már lent – rúgjuk
            e.slide=!e.slide; e.dir=(player.x<e.x?1:-1); player.vy=JUMP_V*0.55; beep(600,0.06,'triangle'); }
        }
      } else {
        // sérülés
        if(player.big){ player.big=false; // visszazsugorodás
          player.y-=10; player.vy=-220; beep(320,0.1,'triangle'); }
        else respawn();
      }
    }
  }

  // shell ellenség eltalál másokat
  for(const s of enemies){ if(!(s.type==='turtle'&&s.shell&&s.slide)&&s.alive) continue; for(const o of enemies){ if(o===s||!o.alive) continue; if(AABB(s,o)){ o.alive=false; player.score+=10; beep(420,0.04,'square'); }} }

  // cél
  if(goal && AABB(player,{x:goal.x-6,y:goal.y,w:goal.w+12,h:goal.h})) finish();

  // kamera dead‑zone
  const target = clamp(player.x - VW/2 + 40, 0, W*TILE - VW);
  camX += (target - camX) * 0.12;
}

function powerUp(){ if(!player.big){ player.big=true; player.y-=10; beep(700,0.12,'sawtooth'); player.score+=10; }}

function respawn(init=false){ if(!init){ player.lives--; if(player.lives<0){ gameOver(); return; } }
  player.x=player.spawn.x; player.y=player.spawn.y; player.vx=0; player.vy=0; player.onGround=false; player.coyote=0; player.jbuf=0; player.wantCut=false; }
function finish(){ run=false; alert(`Nyertél! Pont: ${player.score} – Idő: ${timeEl.textContent}s`); }
function gameOver(){ run=false; alert(`Vége! Pont: ${player.score} – Idő: ${timeEl.textContent}s`); }

/* ====== Rajzolás ====== */
function draw(){
  ctx.setTransform(SCALE,0,0,SCALE,0,0);
  ctx.clearRect(0,0,VW,VH);
  drawBackground();
  // csempe réteg
  for(let y=0;y<H;y++){
    for(let x=0;x<W;x++){
      const ch=tileAt(x,y); const px=x*TILE - camX, py=y*TILE; if(px<-TILE||px>VW||py<-TILE||py>VH) continue;
      if(ch==='#'||ch==='=') drawGround(px,py);
      if(ch==='|') drawPipe(px,py);
      if(ch==='B'){ drawBrick(px,py); }
      if(ch==='?'){ const b=blocks.find(bb=>bb.x===x*TILE && bb.y===y*TILE && bb.kind!=='brick'); drawQ(px,py,b&&b.hit); }
      if(ch==='G') drawFlag(px+2, py-96);
    }
  }
  // érmék
  for(const c of coins){ const px=c.x - camX, py=c.y; if(px<-16||px>VW+16) continue; drawCoin(px,py,c.t); }
  // kérdő/brick a blocks listából (ha időközben változott)
  for(const b of blocks){ const px=b.x - camX, py=b.y; if(px<-TILE||px>VW) continue; if(b.kind==='brick') drawBrick(px,py); else drawQ(px,py,b.hit); }
  // itemek
  for(const it of items){ const px=it.x - camX, py=it.y; drawMush(px,py); }
  // ellenségek
  for(const e of enemies){ if(!e.alive) continue; const px=e.x - camX, py=e.y; if(e.type==='goomba') drawGoomba(px,py); else drawTurtle(px,py,e.shell,e.slide); }
  // játékos
  drawPlayer(player.x - camX, player.y, player.big, player.facing);
}

function drawBackground(){
  // talaj sáv
  ctx.fillStyle='#dff5ff'; ctx.fillRect(0,VH-60,VW,60);
  // dombok parallax
  ctx.fillStyle=getVar('--hill1'); tri(80-camX*0.3,VH-60,100); tri(300-camX*0.25,VH-60,140); tri(560-camX*0.2,VH-60,120);
  ctx.fillStyle=getVar('--hill2'); tri(180-camX*0.2,VH-60,70); tri(420-camX*0.18,VH-60,90);
  // felhők
  cloud(120-camX*0.1,60); cloud(360-camX*0.12,40); cloud(640-camX*0.08,70);
}
function tri(cx,by,s){ ctx.beginPath(); ctx.moveTo(cx,by); ctx.lineTo(cx-s,by); ctx.lineTo(cx,by-s); ctx.closePath(); ctx.fill(); }
function cloud(x,y){ bubble(x,y,12); bubble(x+12,y-6,10); bubble(x+26,y,12); bubble(x+38,y-4,8); }
function bubble(x,y,r){ ctx.beginPath(); ctx.arc(x,y,r,0,Math.PI*2); ctx.fillStyle='rgba(255,255,255,.95)'; ctx.fill(); }

function drawGround(x,y){ ctx.fillStyle=getVar('--ground'); ctx.fillRect(x,y,TILE,TILE); ctx.fillStyle=getVar('--groundTop'); ctx.fillRect(x,y+TILE-4,TILE,4); }
function drawBrick(x,y){ ctx.fillStyle=getVar('--brick'); rr(x,y,16,16,2); ctx.fill(); ctx.fillStyle=getVar('--brick2'); ctx.fillRect(x,y+12,16,4); }
function drawQ(x,y,hit){ ctx.fillStyle = hit?getVar('--qHit'):getVar('--q'); rr(x,y,16,16,3); ctx.fill(); ctx.fillStyle=getVar('--q2'); ctx.fillRect(x+6,y+4,2,2); ctx.fillRect(x+8,y+4,2,2); ctx.fillRect(x+6,y+8,2,2); ctx.fillRect(x+8,y+8,2,2); ctx.fillRect(x+7,y+12,2,2); }
function drawPipe(x,y){ ctx.fillStyle=getVar('--pipe'); ctx.fillRect(x,y,16,16); ctx.fillStyle=getVar('--pipe2'); ctx.fillRect(x+2,y+11,12,5); }
function drawCoin(x,y,t){ ctx.save(); ctx.translate(x,y); ctx.rotate(Math.sin(t*8)*0.2); rr(-6,-6,12,12,6); ctx.fillStyle=getVar('--coin'); ctx.fill(); ctx.restore(); }
function drawFlag(x,y){ ctx.fillStyle='#9ca3af'; ctx.fillRect(x,y,4,96); ctx.fillStyle=getVar('--flag'); ctx.beginPath(); ctx.moveTo(x+4,y+14); ctx.lineTo(x+28,y+8); ctx.lineTo(x+28,y+22); ctx.closePath(); ctx.fill(); ctx.fillStyle=getVar('--flag2'); ctx.fillRect(x-6,y+92,16,4); }
function drawGoomba(x,y){ ctx.fillStyle=getVar('--enemy'); rr(x,y,14,12,3); ctx.fill(); ctx.fillStyle=getVar('--eye'); ctx.fillRect(x+3,y+4,2,2); ctx.fillRect(x+9,y+4,2,2); }
function drawTurtle(x,y,shell,slide){ if(shell){ ctx.fillStyle=getVar('--shell'); rr(x,y,14,10,4); ctx.fill(); ctx.fillStyle=getVar('--shell2'); ctx.fillRect(x+2,y+6,10,3); } else { ctx.fillStyle=getVar('--shell'); rr(x,y,14,14,4); ctx.fill(); ctx.fillStyle=getVar('--shell2'); ctx.fillRect(x+2,y+10,10,3); } }
function drawMush(x,y){ ctx.fillStyle='#ff4d4d'; rr(x,y,12,12,4); ctx.fill(); ctx.fillStyle='#fff'; ctx.fillRect(x+3,y+3,2,2); ctx.fillRect(x+7,y+5,2,2); }
function drawPlayer(x,y,big,face){ const h=big?24:14, w=12; ctx.fillStyle=getVar('--player'); rr(x,y-h,w,h,3); ctx.fill(); ctx.fillStyle=getVar('--hat'); ctx.fillRect(x,y-h-3,w,3); ctx.fillStyle=getVar('--eye'); ctx.fillRect(x+8,y-h+3,2,2); }
function rr(x,y,w,h,r){ const t=Math.min(r,Math.abs(w)/2,Math.abs(h)/2); ctx.beginPath(); ctx.moveTo(x+t,y); ctx.arcTo(x+w,y,x+w,y+h,t); ctx.arcTo(x+w,y+h,x,y+h,t); ctx.arcTo(x,y+h,x,y,t); ctx.arcTo(x,y,x+w,y,t); ctx.closePath(); }
function getVar(n){ return getComputedStyle(document.documentElement).getPropertyValue(n).trim(); }

/* ====== Ciklus ====== */
function frame(){ const now=performance.now()/1000; let dt=now-last; last=now; acc+=dt; if(dt>0.25) acc=0; while(acc>=DT){ update(DT); acc-=DT; } draw(); if(run) requestAnimationFrame(frame); }

/* ====== UI ====== */
id('reset').onclick=()=>{ player.lives=3; player.score=0; player.big=false; clock=0; respawn(true); run=true; };
id('pause').onclick=()=>{ run=!run; if(run){ last=performance.now()/1000; requestAnimationFrame(frame);} };

/* ====== Start ====== */
function init(){ build(); last=performance.now()/1000; requestAnimationFrame(frame); }
document.addEventListener('DOMContentLoaded', init);
</script>
</body>
</html>


